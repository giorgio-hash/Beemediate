<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FTPWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">beemediate</a> &gt; <a href="index.source.html" class="el_package">com.beemediate.beemediate.infrastructure.ftp</a> &gt; <span class="el_source">FTPWriter.java</span></div><h1>FTPWriter.java</h1><pre class="source lang-java linenums">package com.beemediate.beemediate.infrastructure.ftp;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

import com.beemediate.beemediate.domain.pojo.confirmation.Confirmation;
import com.beemediate.beemediate.domain.pojo.order.Order;
import com.beemediate.beemediate.domain.pojo.order.OrderStructure;
import com.beemediate.beemediate.domain.ports.infrastructure.ftp.FTPHandlerPort;
import com.beemediate.beemediate.infrastructure.ftp.config.FTPConfig;
import com.beemediate.beemediate.infrastructure.ftp.mapper.DataMapper;

/**
 * Adattatore di FTPHandlerPort che tratta la gestione dei file XML nel sistema FTP. 
 * Nello specifico, tratta 
 * &lt;ul&gt;
 * &lt;li&gt;la serializzazione POJO a XML-OpenTrans&lt;/li&gt;
 * &lt;li&gt; il posizionamento delle strutture dati nel filesystem destinato alla comunicazione tra i partner commerciali&lt;/li&gt; 
 * &lt;/ul&gt;
 * Questo adattatore &lt;b&gt;&lt;u&gt;non tratta il protocollo di comunicazione FTP&lt;/u&gt;&lt;/b&gt;, bensì tratta le strutture dati trasmesse e ricevute sul sistema dedicato.
 */
@Component
public class FTPWriter implements FTPHandlerPort{

	/**
	 * Riferimento al Logger della classe
	 */
<span class="fc" id="L43">	private final Logger log = LoggerFactory.getLogger(FTPWriter.class);</span>
	
	/**
	 * oggetto di configurazione del filesystem FTP
	 */
	private final FTPConfig ftp;
	/**
	 * Formattazione DateTime
	 */
<span class="fc" id="L52">    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy_MM_dd_HH_mm_ss&quot;);</span>
	
    /**
     * Costruttore
     * @param ftp - bean di configurazione FTPConfig
     */
    @Autowired 
<span class="fc" id="L59">	public FTPWriter(FTPConfig ftp) {</span>
<span class="fc" id="L60">		this.ftp = ftp;</span>
<span class="fc" id="L61">	}</span>
	
	
	@Override
	public boolean archive(Confirmation c) {
		
<span class="nc" id="L67">		Path sourcePath = Paths.get(ftp.getOutboundFolder(), c.getConfirmationId());</span>
<span class="nc" id="L68">		Path targetPath = Paths.get(ftp.getArchivedFolder(), c.getConfirmationId());</span>
		
        try {

            // Sposta il file
<span class="nc" id="L73">            Files.move(sourcePath, targetPath, StandardCopyOption.ATOMIC_MOVE);</span>

<span class="nc" id="L75">            log.info(&quot;File spostato con successo da {} a {}&quot;,sourcePath,targetPath);</span>
<span class="nc" id="L76">            return true;</span>
<span class="nc" id="L77">        } catch (NoSuchFileException e) {</span>
<span class="nc" id="L78">            log.error(&quot;Il file sorgente non esiste.&quot;,e);</span>
<span class="nc" id="L79">        } catch (IOException e) {</span>
<span class="nc" id="L80">            log.error(&quot;Errore durante lo spostamento del file.&quot;,e);</span>
<span class="nc" id="L81">        }</span>
        
<span class="nc" id="L83">        return false;</span>
		
	}


	@Override
	public boolean loadOrder(final Order o) {
<span class="nc" id="L90">		return loadOrder(o.getData());</span>
	}

	/**
	 * Converte il POJO {@code OrderStructure} in una struttura &lt;i&gt;Serializable&lt;/i&gt;, per poi salvare la struttura dati su file {@code .xml}, conforme al formato XML-OpenTrans, al percorso specificato da &lt;i&gt;inbound&lt;/i&gt;
	 * @param os - oggetto {@code OrderStructure}
	 * @return &lt;i&gt;true&lt;/i&gt; se l'operazione è andata a buon fine
	 */
	private boolean loadOrder(final OrderStructure os) {
		
		
<span class="nc" id="L101">		final String content = DataMapper.serializeXmlOrder(DataMapper.mapOrderToXml(os));</span>
<span class="nc" id="L102">		final String fileName = new StringBuilder()</span>
<span class="nc" id="L103">										.append(&quot;ORDER__&quot;)</span>
<span class="nc" id="L104">										.append(LocalDateTime.now().format(FORMATTER))</span>
<span class="nc" id="L105">										.append(&quot;.xml&quot;)</span>
<span class="nc" id="L106">										.toString();</span>
		
<span class="nc" id="L108">		final Path filePath = Paths.get(ftp.getInboundFolder(), fileName); </span>
		 
<span class="nc" id="L110">		return writeToInbound(content, filePath);</span>
	}
	
	
	/**
	 * Al percorso &lt;i&gt;filePath&lt;/i&gt;, crea un nuovo file scrivendoci &lt;i&gt;content&lt;/i&gt;.
	 * @param content - String da scrivere
	 * @param filePath - {@code Path} indicante il percorso al file creato
	 * @return &lt;i&gt;true&lt;/i&gt; se l'operazione è andata a buon fine
	 */
	private boolean writeToInbound(final String content, final Path filePath) {
		
        try {
            // Crea la directory se non esiste
<span class="nc" id="L124">            Files.createDirectories(filePath.getParent());</span>

            // Scrive il contenuto nel file (sovrascrive se esiste)
<span class="nc" id="L127">            Files.write(filePath, content.getBytes(StandardCharsets.UTF_8),</span>
                        StandardOpenOption.CREATE,
                        StandardOpenOption.TRUNCATE_EXISTING);

<span class="nc" id="L131">            log.info(&quot;File scritto con successo: {}&quot;, filePath.toAbsolutePath().toString().replaceAll(&quot;[\r\n]&quot;,&quot;&quot;) );</span>
<span class="nc" id="L132">        } catch (IOException e) {</span>
<span class="nc" id="L133">        	log.error(&quot;Problema di scrittura sul filesystem:&quot;.concat(filePath.toAbsolutePath().toString().replaceAll(&quot;[\r\n]&quot;,&quot;&quot;) ),e);</span>
<span class="nc" id="L134">        }</span>
<span class="nc" id="L135">        return Files.exists(filePath);</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>